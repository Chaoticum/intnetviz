<!DOCTYPE html>
<!-- Initial code was (long ago) 04_force.html by Scott Murray -->
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Network transition</title>
        <script src="include/js/d3.v3.js" charset="utf-8"></script>
        <script src="include/js/d3.slider.js" charset="utf-8"></script>
        <link rel="stylesheet" href="include/css/d3.slider.css" />
        <link rel="stylesheet" href="include/css/styles.css" />   
    </head>
    <body>
        <div id='conteneurPrincipal'>
            <div id='step'></div>
            <div>Slider with slide event: <span id="slidertext">1</span></div>
            <div id='slider'></div>
            <div id='conteneurReseau'></div>
            <div id='conteneurTexte'>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quaerat voluptate dignissimos maxime adipisci asperiores cumque, ut eum earum consequuntur odio laboriosam aut nihil laudantium soluta, et, nulla veniam quod similique.</div>
        </div>
        <script type="text/javascript">

            //Width and height
            var w = 640;
            var h = 480;
            
            // rapidité d'animation
            var step_duration = 20;

            // Import data

            // Variable de contrôle de la transition
            var whichstep = 0;
            var temp = [];

            // nodes
            d3.tsv("../data/moliere/l_ecole_des_femmes_personnages.txt", function(d) {
                var element = document.getElementById("step");
                element.innerHTML = "<p>Pièce</p>" + d[whichstep].piece 
                                        + "<p>Acte</p>" + d[whichstep].acte  
                                        + "<p>Scène</p>" + d[whichstep].scene 
                                        + "<p>Réplique</p>" +d[whichstep].replique;
                // pour tester que les données soient bien chargées
                // console.log(d);
                temp = d;
                // colnames donne le nom de toutes les colonnes
                // mais nous n'en aurons peut-être pas besoin
                var colnames = Object.keys(d[0]);
                // ici les noms des personnages, qui donnent aussi les "keys" du tableau de données
                var nodes_names = colnames.slice(4, colnames.length);
                // nodes est composé d'un objet par noeud
                // chaque noeud a un nom (key) et un array qui donne tous ses états
                var tmp_nodes = [];
                for (var i = 0; i < nodes_names.length; i++) {
                    var tmp_node_states = [];
                    for (var j = 0; j < d.length; j++) {
                        tmp_node_states.push(+d[j][nodes_names[i]]);
                    }
                    tmp_nodes.push({
                        name: nodes_names[i],
//                      x: Math.random()*w,
//                      y: Math.random()*h,
                        fixed: false,       // mis ceci a false, AX
                        step: tmp_node_states,
                    });
                }

                // Precalcul des états et poids des arêtes; le poids est 
                // defini comme la proportion des repliques ou les deux 
                // personnages en question sont copresents; 4 etats sont
                // possibles:
                // - never_live (NL)
                // - not_yet_live (NYL)
                // - previously_live (PL)
                // - live (L)
                var tmp_edges = [];
                // Pour chaque paire de noeuds...
                for (var i = 0; i < nodes_names.length-1; i++) {
                    for (var j = i+1; j < nodes_names.length; j++) {
                        var tmp_state_array = []
                        // Calculer le nombre total de copresences et
                        // construire le vecteur des copresences...
                        var num_copresences = 0;
                        var copresences = []
                        for (var k = 0; k < d.length; k++) {
                            var copresence = d[k][nodes_names[i]] 
                                           * d[k][nodes_names[j]]
                                           ;
                            num_copresences += copresence;
                            copresences.push(copresence)
                        }
                        // Si ces noeuds ne sont jamais copresents...
                        if (num_copresences === 0) {
                            // Tous les etats sont NL.
                            tmp_state_array = Array
                                              .apply(null, Array(d.length))
                                              .map(
                                                  function() {
                                                      return 'never_live'
                                                  }
                                               );
                        }
                        // Si ces noeuds sont copresents au moins une fois...
                        else {
                            // Initialisations...
                            var has_been_live = 0;
                            var tmp_state_array = [];
                            // Pour chaque replique...
                            for (var k = 0; k < d.length; k++) {
                                // Si ces noeuds sont copresents => L 
                                if (copresences[k] === 1) {
                                    tmp_state_array.push('live')
                                    has_been_live = 1;
                                }
                                // Sinon, s'ils ont deja ete copresents => PL
                                else if (has_been_live === 1) {
                                    tmp_state_array.push('previously_live')
                                }
                                // Sinon => NYL
                                else {
                                    tmp_state_array.push('not_yet_live')
                                }
                            }
                        }
                        // Stocker le poids et la sequence d'etats...
                        tmp_edges.push({
                            source: i,
                            target: j,
                            value:  num_copresences/d.length,
                            step:   tmp_state_array,
                        })
                    }
                }
                
                // dataset
                var dataset = {nodes: tmp_nodes, edges: tmp_edges};

                //Initialize a default force layout, using the nodes and edges in dataset
                var force = d3.layout.force()
                                     .nodes(dataset.nodes)
                                     .links(dataset.edges)
                                     .size([w, h])
                                     .linkDistance(function(d) { return h/2*(1-d.value); })
                                     .charge(-h/2)
                                     .start();

                // //Create SVG element (not responsive)
                // var svg = d3.select("body")
                //          .append("svg")
                //          .attr("width", w)
                //          .attr("height", h)
                //          .on("click", function() {
          //                       whichstep++;
          //                       trans();
                //          }); 

                //Create SVG element (responsive)
                var svg = d3.select("div#conteneurReseau")
                            .append("svg")
                            .attr("id", "playgraph")
                             //better to keep the viewBox dimensions with variables
                            .attr("viewBox", "0 0 " + w + " " + h )
                            .attr("preserveAspectRatio", "xMaxYMax scale")
                            .on("click", function() {
                                whichstep++;
                                trans();
                            });                                                     
                
                // Creation des aretes comme lignes...
                var edges = svg.selectAll("line")
                    .data(dataset.edges)
                    .enter()
                    .append("line")
                    .style("stroke", function(d) {
                        if (d.step[0] === 'not_yet_live') {return "#eeeeee";}
                        else if (d.step[0] === 'previously_live') {return "#1177bb";}
                        else if (d.step[0] === 'live') {return "#ff6600";}
                    })
                    .style("stroke-width", function(d) {
                        if (d.step[0] != 'never_live') {return 1;} else {return 0;}
                    });

                // Creation des noeuds comme cercles...
                var nodes = svg.selectAll("circle")
                    .data(dataset.nodes)
                    .enter()
                    .append("circle")
                    .attr("r", 10)
                    .style("fill", function(d) {
                        if (d.step[0]) {return "#ff6600";} else {return "#1177bb";}
                    });

                // ajout des noms des personnages à chaque noeud
                var labels = svg.selectAll("text")
                    .data(dataset.nodes)
                    .enter()
                    .append("text")
                    .text(function(d) { return d.name; });

                //When force layout ends, this will be called
                force.on("tick", function() {
                    nodes.attr("cx", function(d) { return d.x; })
                         .attr("cy", function(d) { return d.y; });
                    edges.attr("x1", function(d) { return d.source.x; })
                         .attr("y1", function(d) { return d.source.y; })
                         .attr("x2", function(d) { return d.target.x; })
                         .attr("y2", function(d) { return d.target.y; });
                    labels.attr("x", function(d) { return d.x + 10; })
                          .attr("y", function(d) { return d.y - 10; });
                    });

                //Transition
                var trans = function() {
                    element.innerHTML = "<p>Pièce</p>" + d[whichstep].piece 
                    + "<p>Acte</p>" + d[whichstep].acte  
                    + "<p>Scène</p>" + d[whichstep].scene 
                    + "<p>Réplique</p>" +d[whichstep].replique;
                    svg.selectAll("circle")
                        .transition()
                        .duration(step_duration)
                        .style("fill", function(d) {
                            if (d.step[whichstep]) {return "#ff6600";} else {return "#1177bb";}
                        });
                    svg.selectAll("line")
                        .transition()
                        .duration(step_duration)
                    .style("stroke", function(d) {
                        if (d.step[whichstep] === 'not_yet_live') {return "#eeeeee";}
                        else if (d.step[whichstep] === 'previously_live') {return "#1177bb";}
                        else if (d.step[whichstep] === 'live') {return "#ff6600";}
                    })
                    .style("stroke-width", function(d) {
                        if (d.step[whichstep] != 'never_live') {return 1;} else {return 0;}
                    });
                    whichstep++;
                    if (whichstep === dataset.nodes[0].step.length) {
                        whichstep = 0;
                    }
                    else {
                        setTimeout(function(){trans();}, step_duration);
                    }
                };

                d3.select('#slider').call(d3.slider().min(1).value(1).max(temp.length).on("slide", function(evt, value) {
                    d3.select('#slidertext').text(Math.round(value));
                }));
            });
        </script>
    </body>
</html>